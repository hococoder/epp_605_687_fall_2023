<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Mobile Application Development for the iOS Platform"/><link rel="canonical" href="https://hococoder.com/posts/Week02/11-GradebookAppUI"/><meta name="twitter:url" content="https://hococoder.com/posts/Week02/11-GradebookAppUI"/><meta name="og:url" content="https://hococoder.com/posts/Week02/11-GradebookAppUI"/><title>Week 2 - Gradebook App UI | Mobile Application Development for the iOS Platform</title><meta name="twitter:title" content="Week 2 - Gradebook App UI | Mobile Application Development for the iOS Platform"/><meta name="og:title" content="Week 2 - Gradebook App UI | Mobile Application Development for the iOS Platform"/><meta name="description" content="An introduction to the Combine framework."/><meta name="twitter:description" content="An introduction to the Combine framework."/><meta name="og:description" content="An introduction to the Combine framework."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="../../../styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Mobile Application Development for the iOS Platform"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Mobile Application Development for the iOS Platform</a><nav><ul><li><a href="/epp_605_687_spring_2023/posts/Intro/About Me">AboutMe</a></li><li><a href="/epp_605_687_spring_2023/posts/Intro/Example App">ExampleApp</a></li><li><a href="/epp_605_687_spring_2023/posts/Week00/00-Week00Overview">Week0</a></li><li><a href="/epp_605_687_spring_2023/posts/Week01/00-Week01Overview">Week1</a></li><li><a href="/epp_605_687_spring_2023/posts/Week02/00-Week02Overview">Week2</a></li><li><a href="/epp_605_687_spring_2023/posts/Week03/00-Week03Overview">Week3</a></li><li><a href="/epp_605_687_spring_2023/posts/Week04/00-Week04Overview">Week4</a></li><li><a href="/epp_605_687_spring_2023/posts/Week05/00-Week05Overview">Week5</a></li><li><a href="/epp_605_687_spring_2023/posts/Week06/00-Week06Overview">Week6</a></li><li><a href="/epp_605_687_spring_2023/posts/Week07/00-Week07Overview">Week7</a></li><li><a href="/epp_605_687_spring_2023/posts/Week08/00-Week08Overview">Week8</a></li><li><a href="/epp_605_687_spring_2023/posts/Week09/00-Week09Overview">Week9</a></li><li><a href="/epp_605_687_spring_2023/posts/Week10/00-Week10Overview">Week10</a></li><li><a href="/epp_605_687_spring_2023/posts/Week11/00-Week11Overview">Week11</a></li><li><a href="/epp_605_687_spring_2023/posts/Week12/00-Week12Overview">Week12</a></li><li><a href="/epp_605_687_spring_2023/posts/Week13/00-Week13Overview">Week13</a></li><li><a href="/epp_605_687_spring_2023/posts/Week14/00-Week14Overview">Week14</a></li></ul></nav></div></header><div class="wrapper"><h1>Week 2 - Gradebook App UI</h1><p style="float: left">Previous:  <A HREF="../10-TheAppLifecycle/index.html">The App Lifecycle</A></p><p style="float: right">Next:  <A HREF="../12-SwiftUIAndUIKit/index.html" class="nextModule">SwiftUI and UIKit</A></p><BR/><BR/><p class="info"> Just a reminder here: a few videos were made with Xcode 11 from a previous semester, so they will look different from what you have on screen, but the end result should be the same.  If you see any glaring discrepancies, please let me know. </p><p class="new"> 
As with the model, there is a difference in the code for this module versus what is in some of the videos:<BR/>
  - "SchoolClassView" is now called "CourseClassView"<BR/>
</p><h2>Login screen</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_z5s7x14y?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_z5s7x14y&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Let's start with the Login screen. This will use the <code>UserAuth</code> class we defined in the last module to track the state of whether the user has logged into the app.</p><pre><code><span class="keyword">struct</span> LoginScreen: <span class="type">View</span> {
  
  <span class="keyword">@State private var</span> username: <span class="type">String</span>
  <span class="keyword">@State private var</span> password: <span class="type">String</span>
  <span class="keyword">@EnvironmentObject var</span> userAuth: <span class="type">UserAuth</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
</code></pre><p>Here, we've define the struct <code>LoginScreen</code>, which adopts the <code>View</code> protocol. This protocol has one property associated with it - <code>body</code> - that is an opaque return type - <code>some View</code>. This tells the compiler that the final returned type of the computed body property will be some type of <code>View</code> (type inference comes into play here!) and it also abstracts what the <em>exact</em> type will be from users of the <code>LoginScreen</code> object.<br><br>At the start of the struct above, we define three other properties:</p><ul><li><code>username</code> and <code>password</code> properties that are Strings and have a <code>@State</code> property wrapper. This wrapper denotes that this property is going to be modified by this view, and also denotes it as the "source of truth" for this property. No matter where this property will get passed to in your code, it is owned by LoginScreen. Behind the scenes, this creates a binding between the view and that property. When the property changes, the view will <strong>automatically</strong> get refreshed by SwiftUI, with no involvement from the programmer. We'll see how to use this property below.</li><li>A <code>userAuth</code> object (of type <code>UserAuth</code>) that has an <code>@EnvironmentObject</code> property wrapper. This wrapper denotes that this property comes from the app's Environment, which is a central location where certain properties can be stored for retrieval by SwiftUI views without having to worry about passing the property itself around through initializers (you saw this last module).</li></ul><p>Next, let's define the property value that the <code>View</code> protocol requires. Thanks to SwiftUI's capability to respond to changes in underlying model properties, we're going to define two possible states for this body property. If the user is not logged in (as reported by the userAuth object), we'll render a login page. If they are logged in, we'll bring up the main <code>ContentView</code> for the app, which we will define later.<br><br>A recent addition to SwiftUI allows you to use the same underlying mechanism that SwiftUI uses when it comes to making choices like this with regard to what to render. We can make a new property decorated with a <code>@ViewBuilder</code> property wrapper to indicate that we may be building and returning different view types from this property. Here is what it looks like:</p><pre><code>   <span class="keyword">@ViewBuilder
  private var</span> viewToDisplay: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="keyword">if</span> !userAuth.<span class="property">isLoggedIn</span> {
      <span class="type">LoginView</span>(username: <span class="property">$username</span>, password: <span class="property">$password</span>)
    } <span class="keyword">else</span> {
      <span class="type">ContentView</span>(model: <span class="type">ClassAssignmentsModel</span>.<span class="property">designModel</span>)
    }
  }
</code></pre><p>Here, we've decorated the property with <code>@ViewBuilder</code>, and we are defining <code>viewToDisplay</code> as a computed property. In the body of the property, we're returning either a <code>LoginView</code> (which we'll define shortly), or a <code>ContentView</code> with our <code>designModel</code> as the model. The choice of which view to return is based on the result of <code>!userAuth.isLoggedIn</code>. We'll see that in action shortly.</p><p>Now let's define the <code>LoginView</code> struct. For this view we'll define the UI by hand, and with later views we'll see how to use the PreviewCanvas to help layout the elements. The first part of the view is:</p><pre><code><span class="keyword">struct</span> LoginView: <span class="type">View</span> {

  <span class="keyword">@Binding var</span> username: <span class="type">String</span>
  <span class="keyword">@Binding var</span> password: <span class="type">String</span>
  <span class="keyword">@EnvironmentObject var</span> userAuth: <span class="type">UserAuth</span>
    
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">VStack</span> {
      <span class="type">Image</span>(<span class="string">"exam"</span>)
        .<span class="call">resizable</span>()
        .<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
      <span class="type">Text</span>(<span class="string">"Class Information"</span>)
        .<span class="call">font</span>(.<span class="dotAccess">title</span>)
      <span class="type">Spacer</span>(minLength: <span class="number">10</span>)
</code></pre><p>The <code>LoginView</code> has 3 properties like the <code>LoginScreen</code> did, but this time the <code>username</code> and <code>password</code> are <code>@Binding</code>s, not <code>@State</code> property wrappers. Remember, <code>LoginScreen</code> owns those properties as the source of truth so anywhere else we want to use them, we have to pass them in as <code>@Bindings</code>. That's why the call to <code>LoginView</code> has <code>username: $username, password: $password</code> as the arguments. The <code>userAuth</code> <code>@EnvironmentObject</code> is fetched again from the environment - no need to pass it along in the initializer.</p><p>As seen in the code above, the first 3 views within the overall <code>VStack</code> will be an <code>Image</code>, a <code>Text</code> label, and a <code>Spacer</code>. The <code>Image</code> view takes in the name of an image from our assets catalog, and 2 other "methods" are called. These methods are called "modifiers" in SwiftUI parlance, and are used to - shockingly - modify the view's attributes. Here, we're declaring that the image is resizable (handy for dealing with large images), and that its aspect ratio is defined as <code>.fit</code> which is short for Aspect Fit. This means that that aspect ratio of the original image will be honored, but it will be scaled to fit within the frame it gets assigned by the layout system. The <code>Text</code> view gets the text you wish to display as the argument to the view, and a modifier is used here to change the font to the "title" style used in Dynamic Type. Finally the <code>Spacer</code> sets its minimum length (in this case, its height) to 10.<br><br>Next let's define another <code>VStack</code> that will group and align the username, password, and login buttons.</p><pre><code>       <span class="type">VStack</span>(alignment: .<span class="dotAccess">center</span>) {
        <span class="type">HStack</span> {
          <span class="type">Spacer</span>(minLength: <span class="number">50</span>)
          <span class="type">TextField</span>(<span class="string">"Username"</span>, text: <span class="property">$username</span>)
            .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
          <span class="type">Spacer</span>(minLength: <span class="number">50</span>)
        }
        <span class="type">HStack</span> {
          <span class="type">Spacer</span>(minLength: <span class="number">50</span>)
          <span class="type">SecureField</span>(<span class="string">"Password"</span>, text: <span class="property">$password</span>)
            .<span class="call">textFieldStyle</span>(<span class="type">RoundedBorderTextFieldStyle</span>())
          <span class="type">Spacer</span>(minLength: <span class="number">50</span>)
        }
</code></pre><p>In the above code, <code>Spacer</code>s are used to massage the layout to our liking. <code>TextField</code>s - which can accept text, not just display it - are used to take the username and password.</p><ul><li>The first argument of the <code>TextField</code> is what will be put in the text field before the user enters a value, in light grey text, so the user knows what value to enter.</li><li>The second argument is a <code>@Binding</code>, which takes in one of our <code>@Binding</code> properties declared above, with a dollar sign in front of the property name. The dollar sign is an indication that it isn't the String itself we're passing in - it's a binding. As changes are input into the <code>TextField</code>, the value behind the <code>@Binding</code> is updated, which is in fact updating the <code>@Binding</code> object we've defined in the <code>LoginView</code> (and then the <code>@State</code> property in <code>LoginScreen</code>). This will cause the view to redraw itself on each change.</li></ul><p>Finally, we add a <code>Button</code>, which takes in a closure to define the action to take place when the <code>Button</code> is pushed, and a <code>Label</code> to title the button with. Note that this is just one possible initializer for <code>Button</code> - see the documentation for details.</p><pre><code>         <span class="type">Button</span>(action: {
          <span class="keyword">self</span>.<span class="property">userAuth</span>.<span class="call">login</span>()
          }, label: { <span class="type">Text</span>(<span class="string">"Login"</span>)})
      }
        
</code></pre><p>Finally, we add some spacing at the bottom.</p><pre><code>       <span class="type">Spacer</span>(minLength: <span class="number">50</span>)
    }
  }
}
</code></pre><p>Once the user does authenticate and login, the <code>LoginScreen</code> will get a new value from the <code>UserAuth</code> object, and thanks to the binding that takes place, will cause a redraw of the <code>LoginScreen</code> - forcing the "else" branch to be taken, which will display the <code>ContentView</code>.</p><img src="../../../week02/loginAnimation.gif#centerResized" alt="Loginscreen"/><h2>Teacher screen</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_v9kliucl?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_v9kliucl&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Let's use the PreviewCanvas to build the <code>TeacherView</code> (see the example video for the walkthrough - code and comments are below!). Composing your view via the PreviewCanvas and typing it by hand yields the same result - but you may find dropping things into the canvas gives you a bit more control as you are build the user interface</p><p>Start by declaring the struct in the code, which as always adopts the <code>View</code> protocol (we'll define the body property below). We are going to want to format some of the dates in this view, so we need to declare a date formatter, along with a property for the Teacher we want to display.</p><pre><code><span class="keyword">struct</span> TeacherView: <span class="type">View</span> {
  
  <span class="keyword">let</span> teacher:<span class="type">Teacher</span>
  <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
</code></pre><p>Since we need to initialize the date formatter, this means that we can't rely on the struct's auto-generated initializer, so we'll have to make our own, setting the Teacher property and setting the formatter properties to our liking.</p><pre><code>   <span class="keyword">init</span>(teacher: <span class="type">Teacher</span>) {
    <span class="keyword">self</span>.<span class="property">teacher</span> = teacher
    dateFormatter.<span class="property">dateStyle</span> = .<span class="dotAccess">medium</span>
    dateFormatter.<span class="property">timeStyle</span> = .<span class="dotAccess">none</span>
  }
</code></pre><p>Now to the body. Let's get the initial rendering of the view up by clicking on "Resume" in the preview canvas. We'll want to layout a series of items vertically - an <code>Image</code>, 2 <code>Text</code> labels showing the teacher's name and affiliation, and then a <code>Spacer</code> before we add some other information providing finer details.</p><pre><code>  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">VStack</span> {
      <span class="type">Image</span>(teacher.<span class="property">imageName</span>).<span class="call">resizable</span>().<span class="call">aspectRatio</span>(contentMode: .<span class="dotAccess">fit</span>)
      <span class="type">Text</span>(teacher.<span class="property">name</span>).<span class="call">font</span>(.<span class="dotAccess">title</span>)
      <span class="type">Text</span>(teacher.<span class="property">affiliation</span>)
      <span class="type">Spacer</span>().<span class="call">frame</span>(height: <span class="number">20</span>)
</code></pre><p>Now let's add some of the finer details. Start by dropping in a <code>Text</code> view, and then command-clicking on it and choosing "Embed in HStack". This will give us some room to grow horizontally with some other elements in a minute. Next, command-click on the <code>HStack</code> and choose "Embed in VStack". This will put the <code>HStack</code> in a <code>VStack</code> and allow us to insert other <code>HStack</code>s to handle other information.</p><pre><code>      <span class="type">VStack</span> {
</code></pre><p>Inside the <code>HStack</code>, drop in a <code>Spacer</code> from the Library, as well as another <code>Text</code> view. Change the argument of the first text to "Email:" and in the other <code>Text</code> view change the argument to <code>teacher.email</code>. Finally, from the modifiers tab of the library, add a <code>padding</code> modifier, and update the arguments to give 10 points of <code>.bottom</code> padding</p><pre><code>        <span class="type">HStack</span> {
          <span class="type">Text</span>(<span class="string">"Email:"</span>)
          <span class="type">Spacer</span>()
          <span class="type">Text</span>(teacher.<span class="property">email</span>)
        }.<span class="call">padding</span>(.<span class="dotAccess">bottom</span>, <span class="number">10</span>)
</code></pre><p>Before moving on, note that this pattern is something we'll use for each attribute of the <code>Teacher</code> struct. So let's extract that out into its own view and take advantage of SwiftUI's composability features:</p><pre><code><span class="comment">//helper view to build rows of the Teacher detail view - helps reduce code!</span>
<span class="keyword">struct</span> TeacherDetailRow: <span class="type">View</span>  {

 <span class="keyword">var</span> title: <span class="type">String</span>
  <span class="keyword">var</span> value: <span class="type">String</span>

  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">HStack</span> {
      <span class="type">Text</span>(title)
      <span class="type">Spacer</span>()
      <span class="type">Text</span>(value)
    }.<span class="call">padding</span>(.<span class="dotAccess">bottom</span>, <span class="number">10</span>)
  }
}
</code></pre><p>Replace that initial code for the email with a call to the <code>TeacherDetailRow</code> view instead:</p><pre><code>        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Email:"</span>, value: teacher.<span class="property">email</span>)
</code></pre><p>Repeat that for the other attributes:</p><pre><code>        <span class="type">TeacherDetailRow</span>(title: <span class="string">"JHED:"</span>, value: teacher.<span class="property">jhed</span>)
        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Start Date:"</span>, value: <span class="string">"</span>\(dateFormatter.<span class="call">string</span>(from: teacher.<span class="property">startDate</span>))<span class="string">"</span>)
        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Highest Degree:"</span>, value: teacher.<span class="property">highestDegree</span>.<span class="property">rawValue</span>)
        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Classes Taught:"</span>, value: teacher.<span class="property">classesTaught</span>.<span class="property">map</span>{$0.<span class="property">rawValue</span>}.<span class="call">joined</span>(separator: <span class="string">",\n"</span>))
        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Actively Teaching:"</span>, value: teacher.<span class="property">activelyTeaching</span>.<span class="property">map</span>{$0.<span class="property">rawValue</span>}.<span class="call">joined</span>(separator: <span class="string">",\n"</span>))
        <span class="type">TeacherDetailRow</span>(title: <span class="string">"Current Rating:"</span>, value: <span class="type">String</span>(format: <span class="string">"%.2f"</span>, teacher.<span class="property">currentRating</span>))
      }.<span class="call">padding</span>()
    }
  }
}
</code></pre><p>Note that:</p><ul><li>To format the <code>date</code> properly, use string interpolation and the <code>dateFormatter</code> we defined earlier.</li><li>For the <code>highestDegree</code> enum, since we defined it as extending <code>String</code>, we can choose to display the <code>.rawValue</code> here, since it is the text representation</li><li>The <code>classesTaught</code> and <code>activelyTeaching</code> fields use the map method to get the text in a format for output. The map method takes each element (here referenced as <code>$0</code>), grabs the <code>.rawValue</code> (since again we're dealing with an <code>Enum</code>), and calls the <code>.joined(separator:)</code> method to stitch together the elements of the collection, separating them with ",n". This way when they are written out, they are each written on their own line, with commas between them.</li><li>For the <code>currentRating</code>, we'll want to format it as a double with 2 decimal places. This can be done with the <code>String(format:)</code> initializer. This is similar to formatting techniques in C and Java.</li></ul><h2>Assignments screen</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_61m3yysi?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_61m3yysi&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Let's define a table that will hold the list of assignments - this will be what will be shown when a user taps on the table row.</p><pre><code><span class="keyword">struct</span> AssignmentView: <span class="type">View</span> {
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">VStack</span> {
      <span class="type">Text</span>(<span class="string">"Type:</span> \(assignment.<span class="property">assignmentType</span>.<span class="property">rawValue</span>)<span class="string">"</span>)
      <span class="type">Text</span>(<span class="string">"Due</span> \(formatter.<span class="call">string</span>(from: assignment.<span class="property">dueDate</span>))<span class="string">"</span>)
      <span class="type">Text</span>(<span class="string">"Max Grade:</span> \(assignment.<span class="property">maxGrade</span>, specifier: <span class="string">"</span>%.2f")<span class="string">")</span>
      <span class="type">Spacer</span>().<span class="call">frame</span>(height: <span class="number">20</span>)
      <span class="type">Text</span>(<span class="string">"Description:</span> \(assignment.<span class="property">description</span>)<span class="string">"</span>)
      <span class="type">Spacer</span>()
    }.<span class="call">navigationBarTitle</span>(assignment.<span class="property">name</span>)
  }
}
</code></pre><p>This contains a <code>VStack</code> along with <code>Text</code> views for some of the attributes of the assignment. A <code>navigationBarTitle</code> modifier puts the assignment's name as the title on the navigation bar.</p><p>For the table itself, it's easy enough to iterate over the <code>Assignment</code> objects and provide a link to the <code>AssignmentView</code> above. As usual, the struct adopts the View protocol (requiring the body property).</p><pre><code><span class="keyword">struct</span> AssignmentsTableView: <span class="type">View</span> {
</code></pre><p>We'll want to pass in an array of <code>Assignment</code> objects, so declare that here.</p><pre><code>   <span class="keyword">var</span> assignments: [<span class="type">Assignment</span>]
</code></pre><p>To define the body, start by adding a <code>NavigationView</code>. This will wrap whatever view we place inside it inside a view that has a <code>NavigationBar</code> at the top, and allows you to drill down to lower levels of the navigation stack, or pop back up to the top. The Mail app on iOS is a great example of this.</p><pre><code>   <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">NavigationView</span> {
</code></pre><p>Next, add a <code>List</code>, where the arguments are the array of <code>Assignments</code> we added in, as well as an argument that instructs the list how to tell elements from one another. This is done via a <code>keyPath</code> - which here tells the List to use the <code>.id</code> property of the elements in the array (<code>Assignment</code> objects) as the unique identifiers. After the closing parenthesis is a trailing closure. If you were to look at the method signature of List, you would see that the last argument is a closure. Some Swift syntactical sugar, however, allows you to extract that from the rest of the arguments and attach the closure body after the call. The first part of the closure - <code>assignment in</code> - refers to how we'll map the elements of the array to the closure body (think of it as the argument to the closure call). Everything after <code>in</code> is the body of the closure.</p><pre><code>       <span class="type">List</span>(assignments, id: \.<span class="property">id</span>) { assignment <span class="keyword">in</span>
</code></pre><p>To help us navigate from the table to the detail AssignmentView, we'll use a <code>NavigationLink</code>. This takes in a destination - here, our <code>AssignmentView</code>, taking in the assignment object - as well as a label with the label for the table row. Note here that it doesn't just take in a <code>Text</code> View, or a string - it takes in a closure, so you can build your own view here. The type of this label must simply adopt the <code>View</code> protocol. So it can be as simple a <code>Text</code> view or as complicated as a <code>HStack</code> with elements inside it.</p><pre><code>         <span class="type">NavigationLink</span>(destination: <span class="type">AssignmentView</span>(assignment: assignment), label: {<span class="type">Text</span>(<span class="string">"</span>\(assignment.<span class="property">name</span>)<span class="string">"</span>)})
      }.<span class="call">navigationBarTitle</span>(<span class="string">"Assignments"</span>)
    }
  }
}
</code></pre><h2>Course Classes screen</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_nwjz7zge?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_nwjz7zge&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>As with the assignments list, let's do one for the <code>CourseClass</code> view that will show the list of students. Again, you want to compose 2 smaller views that will be used here - a <code>StudentRowTable</code>, which will be comprised of a <code>StudentRowView</code>. Tapping on a row here will take you to the <code>StudentsView</code>. I'm leaving these as an exercise to the reader to figure out - what would put in each of these <code>body</code> blocks?</p><pre><code><span class="keyword">struct</span> StudentsView: <span class="type">View</span> {
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">Text</span>(<span class="string">"REPLACE CODE HERE"</span>)
  }
}
</code></pre><p>In addition to the <code>StudentsView</code> above that shows the details, also make a <code>StudentRowView</code> for use in the <code>StudentTable</code> that you'll define below. It should contain the student's <code>image</code> and <code>name</code>. Make sure the <code>image</code> is properly proportioned!</p><pre><code><span class="keyword">struct</span> StudentRowView: <span class="type">View</span> {
  
  <span class="keyword">var</span> student: <span class="type">Student</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">Text</span>(<span class="string">"REPLACE CODE HERE"</span>)
  }
}
</code></pre><p>The last part would be to build a table to display all students in the class.</p><pre><code><span class="keyword">struct</span> StudentTable: <span class="type">View</span> {
  
  <span class="keyword">var</span> students: [<span class="type">Student</span>]
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">Text</span>(<span class="string">"REPLACE CODE HERE"</span>)
  }
}
</code></pre><p>With those elements in place, we can build the <code>CourseClassView</code>, which primarily holds our <code>StudentTable</code> above. Create a new view called <code>CourseClassView.swift</code>, and add the following code. Note that a modifier has been added to the student table - the <code>.navigationBarTitle</code> method, which puts a title into the <code>NavigationBar</code></p><pre><code><span class="keyword">struct</span> CourseClassView: <span class="type">View</span> {
  
  <span class="keyword">let</span> schoolClass: <span class="type">CourseClass</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    
      <span class="keyword">return</span> <span class="type">NavigationView</span> {
        <span class="type">StudentTable</span>(students: schoolClass.<span class="property">students</span>)
          .<span class="call">navigationBarTitle</span>(<span class="type">Text</span>(schoolClass.<span class="property">className</span>.<span class="property">rawValue</span>)
      }
  }
}
</code></pre><h2>Tying it all together</h2><center> <iframe width="1280" height="720" src="https://cdnapisec.kaltura.com/html5/html5lib/v2.81.2/mwEmbedFrame.php/p/1458241/uiconf_id/14487351/entry_id/1_6xba613n?wid=_1458241&iframeembed=true&playerId=kaltura_player&entry_id=1_6xba613n&flashvars[localizationCode]=en&amp;flashvars[leadWithHTML5]=true&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[mediaProxy.preferedFlavorBR]=2500&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;flashvars[EmbedPlayer.NotPlayableDownloadLink]=true;&wid=1_abkvs1gz"allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Kaltura Player">
  </iframe>
</center><p>Now we have to tie it all together. These views are great by themselves, but we want to present them together on screen. If you recall back to the <code>LoginScreen</code>, the view we wanted to show once logged in is called <code>ContentView</code>. This is in fact the default SwiftUI view that comes with every SwiftUI project.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
</code></pre><p>Here we'll define 2 <code>@State</code> properties. One is the initial selection of the tab view we'll use to present the views. The other is the <code>AssigmentGraderModel</code> that holds our model data.</p><pre><code>  <span class="keyword">@State private var</span> selection = <span class="number">1</span>
  <span class="keyword">@State var</span> model: <span class="type">AssignmentGraderModel</span>
</code></pre><p>Our body is simple here - we've extracted it out to a <code>JSONDataView</code> which we'll define below.</p><pre><code>   <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="comment">//week 2 - json files</span>
    <span class="type">JSONDataView</span>(selection: selection, model: model)
  }
}
</code></pre><p>Here, we've extracted out the view in our body above.</p><pre><code><span class="keyword">struct</span> JSONDataView: <span class="type">View</span> {
</code></pre><p>Here, the two properties that we passed into the JSONDataView are decorated here with a <code>@Binding</code> property wrapper. This says that they are actually bindings to external <code>@State</code> properties</p><pre><code>  <span class="keyword">@Binding var</span> selection: <span class="type">Int</span>
  <span class="keyword">@Binding var</span> model: <span class="type">AssignmentGraderModel</span>
  
  <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
</code></pre><p>The body here will consists of a <code>TabView</code> - which takes in a selection argument that states which tab will be selected first. Each of the views are then declared, and tabItem and tag modifiers are attached, to set the text for the tab as well as an integer identifier for that tab.</p><pre><code>   <span class="type">TabView</span>(selection: <span class="property">$selection</span>) {
      <span class="type">CourseClassView</span>(schoolClass: model.<span class="property">schoolClasses</span>[<span class="number">0</span>])
        .<span class="call">tabItem</span> { <span class="type">Text</span>(<span class="string">"Class"</span>) }
        .<span class="call">tag</span>(<span class="number">1</span>)
      <span class="type">AssignmentsTableView</span>(assignments: model.<span class="property">assignments</span>)
        .<span class="call">tabItem</span> { <span class="type">Text</span>(<span class="string">"Assignments"</span>) }
        .<span class="call">tag</span>(<span class="number">2</span>)
      <span class="type">StudentsView</span>(student: model.<span class="property">students</span>[<span class="number">0</span>]) 
        .<span class="call">tabItem</span> { <span class="type">Text</span>(<span class="string">"Student"</span>) }
        .<span class="call">tag</span>(<span class="number">3</span>)
      <span class="type">TeacherView</span>(teacher: model.<span class="property">teachers</span>[<span class="number">0</span>])
        .<span class="call">tabItem</span> { <span class="type">Text</span>(<span class="string">"Teacher"</span>) }
        .<span class="call">tag</span>(<span class="number">4</span>)
    }
  }
}
</code></pre><p>If we launch this in the simulator, the <code>LoginView</code> loads up, and if we sign in we gets sent to the <code>ContentView</code> we define above. We can explore the behavior in each of the subview, and as we go on through the semester, we'll build on that behavior.<br><br>As you can see, not only is working with SwiftUI declarative, it can be very compositional. Indeed, Apple suggests breaking your UI into smaller views. The rendering system is very optimized towards taking in all of those smaller views and rendering a single view to process.</p><p>With this overview of SwiftUI in hand, let's look at how this plays with the previous way of designing interfaces via the UIKit framework, which we'll cover in the next module.</p><p style="float: left">Previous:  <A HREF="../10-TheAppLifecycle/index.html">The App Lifecycle</A></p><p style="float: right">Next:  <A HREF="../12-SwiftUIAndUIKit/index.html" class="nextModule">SwiftUI and UIKit</A></p><BR/><BR/></div><footer><p>Generated with ❤️ using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>© 2022-2023 Josh Steele (rsteele3@jhu.edu) <a href="mailto:"(rsteele3@jhu.edu)""></a></p><p>Last updated January 16, 2023 at 2:38 PM</p><p><a href="https://twitter.com/hococoder" target="_blank">My Twitter</a> | <a href="https://github.com/hococoder" target="_blank">My GitHub</a> | <a href="https://ep.jhu.edu" target="_blank">Whiting School EPP</a> | <a href="https://blackboard.jhu.edu" target="_blank">JHU Blackboard</a></p></footer></body></html>